{"version":3,"sources":["edamame/core.cljc"],"mappings":";AAIA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BAAA,oCAAAA,hEAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,wDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0DAAA,1DAAMD,qEAsDFE;AAtDJ,AAuDG,0CAAA,nCAACC,iCAAeD;;;AAvDnB,CAAA,0DAAA,1DAAMF,qEAwDFE,EAAEE;AAxDN,AAyDG,OAACD,iCAAeD,EAAEE;;;AAzDrB,CAAA,oDAAA,pDAAMJ;;AAAN,AA2DA,AAAA;;;;gCAAA,wCAAAF,xEAAMQ;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,4DAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,4DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAL,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,8DAAA,9DAAMK,yEAGFJ;AAHJ,AAIG,8CAAA,vCAACK,qCAAmBL;;;AAJvB,CAAA,8DAAA,9DAAMI,yEAKFJ,EAAEE;AALN,AAMG,OAACG,qCAAmBL,EAAEE;;;AANzB,CAAA,wDAAA,xDAAME;;AAAN,AAQA;;;;sBAAA,tBAAME,oDAGHC;AAHH,AAIE,OAACC,2BAASD;;AAEZ;;;;6BAAA,7BAAME,kEAGHF;AAHH,AAIE,OAACG,0CAAwBH;;AAE3B,+BAAA,/BAAMI,sEAAiBC;AAAvB,AACE,OAACC,oCAAkBD;;AAErB,iCAAA,jCAAME,0EAAmBF;AAAzB,AACE,OAACG,sCAAoBH;;AAEvB,8BAAA,9BAAMI,oEAAgBd;AAAtB,AACE,OAACe,mCAAiBf;;AAEpB,AAAA;;;;0BAAA,kCAAAN,5DAAMuB;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,sDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,sDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAApB,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,wDAAA,xDAAMoB,mEAGFP;AAHJ,AAGY,oEAAA,7DAACQ,sDAAWR;;;AAHxB,CAAA,wDAAA,xDAAMO,mEAIFP,OAAOV;AAJX,AAKG,IAAMmB,IAAE,AAACC,6DAAapB,KAAKU;AAA3B,AACE,GAAI,mCAAA,nCAA0BW,0HAA6CF;AACzE,IAAAG,mBAAI,iDAAA,jDAACC,4CAAIvB;AAAT,AAAA,oBAAAsB;AAAAA;;AAAA;;;AAEAH;;;;AATP,CAAA,kDAAA,lDAAMF;;AAAN,AAWA;;;2BAAA,3BAAMO,8DAEHC;AAFH,AAKW,GAAA,GAAA,QAAA,PAAsBA;AAAtB,GAAA,EAAA,CAAA,0CAAA,eAAA,CAAAC,gCAAA,1FAAsBD,0FAAAA;AAAtB;;AAAA,GAAA,EAAA,AAAsBA;AAAtB,OAAAE,kCAAYC,oBAAUH;;AAAtB;;;;AAAA,OAAAE,kCAAYC,oBAAUH;;;AAIjC","names":["var_args","G__40790","edamame.core/parse-string","js/Error","s","edamame.impl.parser/parse-string","opts","G__40794","edamame.core/parse-string-all","edamame.impl.parser/parse-string-all","edamame.core/reader","x","edamame.impl.parser/reader","edamame.core/source-reader","edamame.impl.parser/source-logging-reader","edamame.core/get-line-number","reader","edamame.impl.parser/get-line-number","edamame.core/get-column-number","edamame.impl.parser/get-column-number","edamame.core/normalize-opts","edamame.impl.parser/normalize-opts","G__40801","edamame.core/parse-next","edamame.core.parse_next","v","edamame.impl.parser.parse_next","cljs.core/keyword-identical?","or__4212__auto__","cljs.core.get","edamame.core/iobj?","obj","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/IWithMeta"],"sourcesContent":["(ns edamame.core\n  (:require\n   [edamame.impl.parser :as p]))\n\n(defn parse-string\n  \"Parses first EDN value from string.\n\n  Supported parsing options:\n\n  `:deref`: parse forms starting with `@`. If `true`, the resulting\n  expression will be parsed as `(deref expr)`.\n\n  `:fn`: parse function literals (`#(inc %)`). If `true`, will be parsed as `(fn [%1] (inc %))`.\n\n  `:quote`: parse quoted expression `'foo`. If `true`, will be parsed as `(quote foo)`.\n\n  `:read-eval`: parse read-eval (`=(+ 1 2 3)`). If `true`, the\n  resulting expression will be parsed as `(read-eval (+ 1 2 3))`.\n\n  `:regex`: parse regex literals (`#\\\"foo\\\"`). If `true`, defaults to\n  `re-pattern`.\n\n  `:syntax-quote`: parse syntax-quote (`(+ 1 2 3)`). Symbols get\n  qualified using `:resolve-symbol` which defaults to `identity`:\n  `(parse-string \\\"`x\\\" {:syntax-quote {:resolve-symbol #(symbol \\\"user\\\" (str %))}})\n  ;;=> (quote user/x)`.\n\n  `:var`: parse var literals (`#'foo`). If `true`, the resulting\n  expression will be parsed as `(var foo)`.\n\n  `:all`: when `true`, the above options will be set to `true` unless\n  explicitly provided.\n\n  Supported options for processing reader conditionals:\n\n  `:read-cond`: - `:allow` to process reader conditionals, or\n                  `:preserve` to keep all branches\n  `:features`: - persistent set of feature keywords for reader conditionals (e.g. `#{:clj}`).\n\n  `:auto-resolve`: map of alias to namespace symbols for\n  auto-resolving keywords. Use `:current` as the alias for the current\n  namespace.\n\n  `:readers`: data readers.\n\n  `:postprocess`: a function that is called with a map containing\n  `:obj`, the read value, and `:loc`, the location metadata. This can\n  be used to handle objects that cannot carry metadata differently. If\n  this option is provided, attaching location metadata is not\n  automatically added to the object.\n\n  `:location?`: a predicate that is called with the parsed\n  object. Should return a truthy value to determine if location\n  information will be added.\n\n  Additional arguments to tools.reader may be passed with\n  `:tools.reader/opts`, like `:readers` for passing reader tag functions.\n  \"\n  ([s]\n   (p/parse-string s nil))\n  ([s opts]\n   (p/parse-string s opts)))\n\n(defn parse-string-all\n  \"Like parse-string but parses all values from string and returns them\n  in a vector.\"\n  ([s]\n   (p/parse-string-all s nil))\n  ([s opts]\n   (p/parse-string-all s opts)))\n\n(defn reader\n  \"Coerces x into indexing pushback-reader to be used with\n  parse-next. Accepts: string or java.io.Reader.\"\n  [x]\n  (p/reader x))\n\n(defn source-reader\n  \"Coerces x into source-logging-reader to be used with\n  parse-next. Accepts: string or java.io.Reader.\"\n  [x]\n  (p/source-logging-reader x))\n\n(defn get-line-number [reader]\n  (p/get-line-number reader))\n\n(defn get-column-number [reader]\n  (p/get-column-number reader))\n\n(defn normalize-opts [opts]\n  (p/normalize-opts opts))\n\n(defn parse-next\n  \"Parses next form from reader. Accepts same opts as parse-string, must\n  be normalized with normalize-opts first.\"\n  ([reader] (parse-next reader {}))\n  ([reader opts]\n   (let [v (p/parse-next opts reader)]\n     (if (#?(:clj identical? :cljs keyword-identical?) :edamame.impl.parser/eof v)\n       (or (get opts :eof)\n           ::eof)\n       v))))\n\n(defn iobj?\n  \"Returns true if obj can carry metadata.\"\n  [obj]\n  #?(:clj\n     (instance? clojure.lang.IObj obj)\n     :cljs (satisfies? IWithMeta obj)))\n\n;;;; Scratch\n\n(comment\n  (parse-string \"(1 2 3 #_4)\"))\n"]}