{"version":3,"sources":["zprint/comment.cljc"],"mappings":"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","names":["zprint.comment/blanks","n","cljs.core.apply","cljs.core/str","cljs.core.repeat","zprint.comment/split-lf","s","input","out","cljs.core/not","next-lf","clojure.string.index_of","chunk","cljs.core.subs","cljs.core.conj","zprint.comment/tag-l-size","t","G__30875","cljs.core/Keyword","zprint.comment/left-or-up","zloc","ploc","total-up","next-left","zprint.zutil/left*","moving-up","zprint.zutil/up*","up-tag","zprint.zutil/tag","up-size","zprint.comment/length-after-newline","nl-split","clojure.string.split","nl-num","cljs.core/count","cljs.core/last","zprint.comment/length-before","vec__30877","cljs.core.nth","next-zloc","indent-before","vec__30883","zstr","zprint.zfns/zstring","length-right-of-newline","zprint.comment/inlinecomment?","nloc","spaces","passed-nl?","vec__30901","tnloc","zprint.zfns/ztag","cljs.core._EQ_","nstr","trim-nstr","clojure.string/trimr","nloc-length-before","zloc-length-before","cljs.core.not_EQ_","zprint.zutil/length","zprint.comment/last-space","from-index","x__4298__auto__","y__4299__auto__","rev-seq","cljs.core/reverse","cljs.core.take","seq-after-space","p1__30907#","cljs.core.take_while","space-index","zprint.comment/next-space","p1__30915#","cljs.core.drop","cljs.core/seq","p__30922","vec__30923","zprint.comment/wrap-comment","width","color","stype","element","start","comment-width","semi-str","cljs.core/re-find","rest-str","space-str","newline?","comment-str","cljs.core/transient","cljs.core/empty?","cljs.core/persistent!","cljs.core.conj_BANG_","last-space-index","or__4212__auto__","next-comment","p__30928","vec__30929","zprint.comment/loc-vec","split","zprint.comment/style-loc-vec","indent","style-vec","cljs.core/butlast","cljs.core.reductions","zprint.comment/lift-vec","out-vec","cljs.core/first","element-vec","cljs.core/next","zprint.comment/lift-style-vec","cljs.core.reduce","p__30932","map__30933","cljs.core/--destructure-map","cljs.core.get","zprint.comment/fzprint-wrap-comments","options","cljs.core.println","start-col","_","cljs.core.pr_str","wrap-style-vec","cljs.core.mapv","cljs.core.partial","out-style-vec","zprint.comment/find-element-from-end","element-pred?","index","vec__30935","e","zprint.comment/line-size","cljs.core/+","cljs.core.map","zprint.comment/space-before-comment","indent-index","p1__30939#","this-line-vec","cljs.core/nthnext","p__30941","map__30942","zprint.comment/fzprint-inline-comments","cvec","last-out","vec__30954","vec__30957","vec__30960","c","ne","nn","next-element","cljs.core/second","le","new-element","zprint.comment/max-aligned-inline-comment-distance","zprint.comment/find-aligned-inline-comments","last-indent","current-seq","current-column","distance","vec__30967","start-column","js/Error","zprint.comment/find-consecutive-inline-comments","vec__30979","p__30984","vec__30985","zprint.comment/comment-column","comment-index","cljs.core/vector?","column","p__30988","vec__30989","zprint.comment/comment-vec-column","inline-comment-index","comment-vec","spaces-before","zprint.comment/comment-vec-seq-column","comment-vec-seq","zprint.comment/comment-vec-all-column","comment-vec-all","zprint.comment/minimum-column","minimum-vec","p1__30993#","minimum-col","cljs.core/max","p__30995","vec__30996","zprint.comment/change-start-column","new-start-column","vec__30999","delta-spaces","new-spaces","previous-element-index","previous-element","new-previous-element","cljs.core.assoc","zprint.comment/align-comment-vec","zprint.comment/fzprint-align-inline-comments","style","comment-vec-column"],"sourcesContent":["(ns ^:no-doc zprint.comment\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer [dbg dbg-pr dbg-form dbg-print zfuture]]]])\n  (:require #?@(:clj [[zprint.macros :refer\n                       [dbg-pr dbg dbg-form dbg-print zfuture]]])\n            [clojure.string :as s]\n            [zprint.zfns :refer [zstring ztag]]\n            [zprint.zutil]\n            #_[taoensso.tufte :as tufte :refer (p defnp profiled profile)]))\n\n#_(tufte/add-basic-println-handler! {})\n\n;;\n;; # Utility Functions\n;;\n\n;\n; Interestingly, this is faster than (apply str (repeat n \\space)) by\n; about 30%.\n\n(defn blanks\n  \"Produce a blank string of desired size.\"\n  [n]\n  (apply str (repeat n \" \")))\n\n(defn split-lf\n  \"Do split for newlines, instead of using regular expressions.\"\n  [s]\n  (loop [input s\n         out []]\n    (if-not input\n      out\n      (let [next-lf (clojure.string/index-of input \"\\n\")\n            chunk (if next-lf (subs input 0 next-lf) input)]\n        (recur (if next-lf (subs input (inc next-lf)) nil) (conj out chunk))))))\n\n(defn tag-l-size\n  \"Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters.\"\n  [t]\n  (case t\n    :list 1\n    :vector 1\n    :set 2\n    :map 1\n    :uneval 2\n    :reader-macro 1\n    :meta 1\n    :quote 1\n    :syntax-quote 1\n    :fn 2\n    :unquote 1\n    :deref 1\n    :namespaced-map 1\n    0))\n\n(defn left-or-up\n  \"Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]\"\n  [zloc]\n  (loop [ploc zloc\n         total-up 0]\n    #_(prn \"left-or-up: ploc:\" (zstring ploc) \"total-up:\" total-up)\n    (let [next-left (zprint.zutil/left* ploc)]\n      (if next-left\n        [total-up next-left]\n        ; can't go left, what about up?\n        (let [moving-up (zprint.zutil/up* ploc)\n              up-tag (when moving-up (zprint.zutil/tag moving-up))\n              up-size (tag-l-size up-tag)]\n          #_(prn \"left-or-up: up-tag:\" up-tag)\n          (if-not moving-up\n            ; can't go up, ran out of expression\n            [total-up nil]\n            (recur moving-up (+ total-up up-size))))))))\n\n(defn length-after-newline\n  \"Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string.\"\n  [s]\n  (let [nl-split (clojure.string/split (str s \" \") #\"\\n\")\n        nl-num (dec (count nl-split))]\n    (when-not (zero? nl-num) (dec (count (last nl-split))))))\n\n(defn length-before\n  \"Given a zloc, find the amount of printing space before it on its\n  current line.\"\n  [zloc]\n  (let [[up-size next-zloc] (left-or-up zloc)]\n    (loop [ploc next-zloc\n           indent-before up-size]\n      (if-not ploc\n        (do #_(prn \"length-before: if-not ploc:\" indent-before) indent-before)\n        ; we assume we have a ploc\n        (let [zstr (if ploc (zstring ploc) \"\")\n              length-right-of-newline (length-after-newline zstr)\n              [up-size next-zloc] (left-or-up ploc)]\n          #_(prn \"length-before: (nil? ploc):\" (nil? ploc)\n                 \"zstr:\" zstr\n                 \"up-size:\" up-size\n                 \"length-right-of-newline:\" length-right-of-newline\n                 \"(tag ploc):\" (zprint.zutil/tag ploc)\n                 \"ploc:\" (zstring ploc)\n                 \"next-zloc:\" (zstring next-zloc))\n          (if length-right-of-newline\n            ; hit a newline\n            (do #_(prn \"length-before: length-right-of-newline:\"\n                         length-right-of-newline\n                       \"indent-before:\" indent-before)\n                (+ length-right-of-newline indent-before))\n            (recur next-zloc (+ indent-before (count zstr) up-size))))))))\n\n;;\n;; # Comment Wrap Support\n;;\n\n(defn inlinecomment?\n  \"If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment.\"\n  [zloc]\n  #_(prn \"inlinecomment? zloc:\" (zstring zloc))\n  (loop [nloc (zprint.zutil/left* zloc)\n         spaces 0\n         passed-nl? false]\n    (let\n      #?(:clj [tnloc (ztag nloc)]\n         :cljs [[tnloc spaces]\n                (let [tnloc (ztag nloc)]\n                  (if (= tnloc :whitespace)\n                    ; might be whitespace with an embedded comma in cljs\n                    (let [nstr (zstring nloc)\n                          trim-nstr (clojure.string/trimr nstr)]\n                      (if (pos? (count trim-nstr))\n                        ; it had something besides spaces in it\n                        ; we will assume a comma\n                        ;  correct things\n                        [:comma (+ spaces (- (count nstr) (count trim-nstr)))]\n                        ; it was all whitespace -- don't correct\n                        [:whitespace spaces]))\n                    [tnloc spaces]))])\n      #_(prn \"inlinecomment? tnloc:\" tnloc\n             \"spaces:\" spaces\n             \"nloc:\" (zstring nloc))\n      (cond\n        (nil? tnloc) nil  ; the start of the zloc\n        (= tnloc :newline) (recur (zprint.zutil/left* nloc) spaces true)\n        (or (= tnloc :comment) (= tnloc :comment-inline))\n          ; Two comments in a row don't have a newline showing between\n          ; them, it is captured by the first comment.  Sigh.\n          ; Except now it isn't, as we split the newlines out.\n          (do #_(prn \"inlinecomment? found previous comment!\")\n              ; is it an inline comment?\n              (when (inlinecomment? nloc)\n                ; figure the total alignment from the newline\n                (let [nloc-length-before (length-before nloc)\n                      zloc-length-before (length-before zloc)]\n                  #_(prn \"inlinecomment?:\"\n                         \"nloc-length-before:\" nloc-length-before\n                         \"zloc-length-before:\" zloc-length-before\n                         \"spaces:\" spaces)\n                  (if (= nloc-length-before zloc-length-before)\n                    ; we have a lineup\n                    [spaces zloc-length-before]\n                    nil))))\n        (not= tnloc :whitespace)\n          (if passed-nl? nil [spaces (length-before zloc)])\n        :else (recur (zprint.zutil/left* nloc)\n                     ^long (+ ^long (zprint.zutil/length nloc) spaces)\n                     passed-nl?)))))\n\n(defn last-space\n  \"Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (min (dec (count s)) from-index)\n        rev-seq (reverse (take (inc from-index) s))\n        seq-after-space (take-while #(not= % \\space) rev-seq)\n        space-index (- from-index (count seq-after-space))]\n    (if (neg? space-index) nil space-index)))\n\n(defn next-space\n  \"Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (inc from-index)]\n    (when (< from-index (count s))\n      (let [seq-after-space (take-while #(not= % \\space)\n                                        (drop from-index (seq s)))\n            space-index (+ from-index (count seq-after-space))]\n        (if (>= space-index (count s)) nil space-index)))))\n\n; transient may have made this worse\n(defn wrap-comment\n  \"If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case.\"\n  [width [s color stype :as element] start]\n  (if-not (or (= stype :comment) (= stype :comment-inline))\n    element\n    (let [comment-width (- width start)\n          semi-str (re-find #\";*\" s)\n          rest-str (subs s (count semi-str))\n          space-str (re-find #\" *\" rest-str)\n          rest-str (subs rest-str (count space-str))\n          newline? (re-find #\"\\n$\" s)\n          comment-width (- comment-width (count semi-str) (count space-str))\n          #_(println \"\\ncomment-width:\" comment-width\n                     \"semi-str:\" semi-str\n                     \"space-str:\" space-str\n                     \"rest-str:\" rest-str)]\n      (loop [comment-str rest-str\n             out (transient [])]\n        #_(prn \"comment-str:\" comment-str)\n        (if (empty? comment-str)\n          (if (zero? (count out))\n            (if newline?\n              [[semi-str color stype] [\"\\n\" :none :indent 38]]\n              [[semi-str color stype]])\n            (persistent! (if newline? (conj! out [\"\\n\" :none :indent 39]) out)))\n          (let [last-space-index (if (<= (count comment-str) comment-width)\n                                   (dec (count comment-str))\n                                   (if (<= comment-width 0)\n                                     (or (next-space comment-str 0)\n                                         (dec (count comment-str)))\n                                     (or (last-space comment-str comment-width)\n                                         (next-space comment-str comment-width)\n                                         (dec (count comment-str)))))\n                next-comment (clojure.string/trimr\n                               (subs comment-str 0 (inc last-space-index)))]\n            #_(prn \"last-space-index:\" last-space-index\n                   \"next-comment:\" next-comment)\n            (recur\n              (subs comment-str (inc last-space-index))\n              (if (zero? (count out))\n                ;(empty? out)\n                (conj! out [(str semi-str space-str next-comment) color stype])\n                (conj! (conj! out [(str \"\\n\" (blanks start)) :none :indent 40])\n                       [(str semi-str space-str next-comment) color\n                        :comment-wrap])))))))))\n\n(defn loc-vec\n  \"Takes the start of this vector and the vector itself.\"\n  [start [s]]\n  (let [split (split-lf s)]\n    (if (= (count split) 1) (+ start (count s)) (count (last split)))))\n\n(defn style-loc-vec\n  \"Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent.\"\n  [indent style-vec]\n  (butlast (reductions loc-vec indent style-vec)))\n\n; Transient didn't help here, rather it hurt a bit.\n\n(defn lift-vec\n  \"Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector.\"\n  [out-vec element]\n  (if (string? (first element))\n    (conj out-vec element)\n    (loop [element-vec element\n           out out-vec]\n      (if-not element-vec\n        out\n        (recur (next element-vec) (conj out (first element-vec)))))))\n\n(defn lift-style-vec\n  \"Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors.\"\n  [style-vec]\n  (reduce lift-vec [] style-vec))\n\n(defn fzprint-wrap-comments\n  \"Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for \"\n  [{:keys [width], :as options} style-vec]\n  (dbg options \"fzprint-wrap-comments: indent:\" (:indent options))\n  #_(def wcsv style-vec)\n  (let [start-col (style-loc-vec (or (:indent options) 0) style-vec)\n        #_(def stc start-col)\n        _ (dbg options \"fzprint-wrap-comments: style-vec:\" (pr-str style-vec))\n        _ (dbg options \"fzprint-wrap-comments: start-col:\" start-col)\n        wrap-style-vec (mapv (partial wrap-comment width) style-vec start-col)\n        #_(def wsv wrap-style-vec)\n        _ (dbg options \"fzprint-wrap-comments: wrap:\" (pr-str style-vec))\n        out-style-vec (lift-style-vec wrap-style-vec)]\n    out-style-vec))\n\n(defn find-element-from-end\n  \"Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element.\"\n  [element-pred? style-vec]\n  (loop [index (dec (count style-vec))]\n    (if (neg? index)\n      nil\n      (let [[_ _ e] (nth style-vec index)]\n        (if (element-pred? e) index (recur (dec index)))))))\n\n(defn line-size\n  \"Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines.\"\n  [style-vec]\n  (apply + (map (partial loc-vec 0) style-vec)))\n\n(defn space-before-comment\n  \"Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line.\"\n  [style-vec]\n  (let [indent-index (find-element-from-end #(or (= % :indent) (= % :newline))\n                                            style-vec)\n        this-line-vec\n          (if indent-index (nthnext style-vec indent-index) style-vec)]\n    (line-size (butlast this-line-vec))))\n\n(defn fzprint-inline-comments\n  \"Try to bring inline comments back onto the line on which they belong.\"\n  [{:keys [width], :as options} style-vec]\n  #_(def fic style-vec)\n  (dbg-pr options \"fzprint-inline-comments:\" style-vec)\n  (loop [cvec style-vec\n         last-out [\"\" nil nil]\n         out []]\n    (if-not cvec\n      (do #_(def fico out) out)\n      (let [[s c e :as element] (first cvec)\n            [_ _ ne nn :as next-element] (second cvec)\n            [_ _ le] last-out\n            new-element\n              (cond (and (or (= e :indent) (= e :newline))\n                         (= ne :comment-inline))\n                      (if-not (or (= le :comment) (= le :comment-inline))\n                        ; Regular line to get the inline comment\n                        [(blanks nn) c :whitespace 25]\n                        ; Last element was a comment...\n                        ; Can't put a comment on a comment, but\n                        ; we want to indent it like the last\n                        ; comment.\n                        ; How much space before the last comment?\n                        (do #_(prn \"inline:\" (space-before-comment out))\n                            [(str \"\\n\" (blanks (space-before-comment out))) c\n                             :indent 41]\n                            #_element))\n                    :else element)]\n        (recur (next cvec) new-element (conj out new-element))))))\n\n;;\n;; ## Align inline comments\n;;\n\n(def max-aligned-inline-comment-distance 5)\n\n(defn find-aligned-inline-comments\n  \"Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec.\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         current-column 0\n         distance 0\n         out []]\n    (if-not cvec\n      (let [out (if (> (count current-seq) 1) (conj out current-seq) out)]\n        #_(def fcico out)\n        out)\n      (let [[s c e spaces start-column :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (if (= start-column current-column)\n              ; include this inline comment in the current-seq, since\n              ; it has the same starting column\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       (conj current-seq [last-indent index])\n                       (do (throw\n                             (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"find-aligned-inline-comments a:\" index)))\n                           []))\n                     current-column\n                     ; distance from last inline comment is zero\n                     0\n                     out)\n              ; start a new current-seq, since this comment's starting\n              ; column doesn't match the current-column of the current-seq\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       [[last-indent index]]\n                       (do (throw\n                             (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"find-aligned-inline-comments b:\" index)))\n                           []))\n                     ; new starting column\n                     start-column\n                     ; distance from the last inline comment is zero\n                     0\n                     ; if we have more than one current inline comments,\n                     ; add them to the out vector\n                     (if (> (count current-seq) 1) (conj out current-seq) out)))\n          (or (= e :indent) (= e :newline))\n            (if (>= distance max-aligned-inline-comment-distance)\n              ; We have gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     []\n                     ; current-column\n                     0\n                     ; distance\n                     0\n                     (if (> (count current-seq) 1) (conj out current-seq) out))\n              ; We have not gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     current-seq\n                     current-column\n                     ; we've passed another line\n                     (inc distance)\n                     out))\n          :else (recur (next cvec)\n                       (inc index)\n                       last-indent\n                       current-seq\n                       current-column\n                       distance\n                       out))))))\n\n(defn find-consecutive-inline-comments\n  \"Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         out []]\n    (if-not cvec\n      (do #_(def fcico out) out)\n      (let [[s c e :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (recur (next cvec)\n                   (inc index)\n                   nil\n                   (if last-indent\n                     (conj current-seq [last-indent index])\n                     (do (throw\n                           (#?(:clj Exception.\n                               :cljs js/Error.)\n                            (str \"find-consecutive-inline-comments:\" index)))\n                         []))\n                   out)\n          (or (= e :indent) (= e :newline))\n            (recur (next cvec)\n                   (inc index)\n                   index\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment\n                     []\n                     ; if we don't have a last-indent, then we\n                     ; did just have a comment previously, so keep\n                     ; collecting comments\n                     current-seq)\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment.  But if we have more\n                     ; than one comment vector in current-seq,\n                     ; make sure we keep track of that\n                     (if (> (count current-seq) 1) (conj out current-seq) out)\n                     ; if we didn't have last-indent, then we\n                     ; just had a comment, so keep collecting\n                     ; them\n                     out))\n          :else (recur (next cvec) (inc index) last-indent current-seq out))))))\n\n(defn comment-column\n  \"Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts.\"\n  [[indent-index comment-index] style-vec]\n  (when-not (vector? style-vec)\n    (throw (#?(:clj Exception.\n               :cljs js/Error.)\n            (str \"comment-column: style-vec not a vector!! \" style-vec))))\n  (loop [index indent-index\n         column 0]\n    (if (= index comment-index)\n      column\n      (recur (inc index) (loc-vec column (nth style-vec index))))))\n\n(defn comment-vec-column\n  \"Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before].\"\n  [style-vec [indent-index inline-comment-index :as comment-vec]]\n  (let [start-column (comment-column comment-vec style-vec)\n        spaces-before (loc-vec 0 (nth style-vec (dec inline-comment-index)))]\n    [inline-comment-index start-column spaces-before]))\n\n(defn comment-vec-seq-column\n  \"Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]\"\n  [style-vec comment-vec-seq]\n  (map (partial comment-vec-column style-vec) comment-vec-seq))\n\n(defn comment-vec-all-column\n  \"Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]\"\n  [style-vec comment-vec-all]\n  (map (partial comment-vec-seq-column style-vec) comment-vec-all))\n\n(defn minimum-column\n  \"Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned.\"\n  [comment-vec]\n  (let [minimum-vec (map #(inc (- (second %) (nth % 2))) comment-vec)\n        minimum-col (apply max minimum-vec)]\n    minimum-col))\n\n(defn change-start-column\n  \"Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column.\"\n  [new-start-column style-vec\n   [inline-comment-index start-column spaces-before :as comment-vec]]\n  (let [delta-spaces (- new-start-column start-column)\n        new-spaces (+ spaces-before delta-spaces)\n        previous-element-index (dec inline-comment-index)\n        #_(prn \"change-start-column:\"\n               \"spaces-before:\" spaces-before\n               \"delta-spaces:\" delta-spaces\n               \"new-spaces:\" new-spaces)\n        [s c e :as previous-element] (nth style-vec previous-element-index)\n        new-previous-element\n          (cond (= e :indent) [(str \"\\n\" (blanks new-spaces)) c e]\n                (= e :whitespace) [(str (blanks new-spaces)) c e 26]\n                :else (throw\n                        (#?(:clj Exception.\n                            :cljs js/Error.)\n                         (str \"change-start-column: comment preceded by neither\"\n                              \" an :indent nor :whitespace!\"\n                              e))))]\n    (assoc style-vec previous-element-index new-previous-element)))\n\n(defn align-comment-vec\n  \"Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec.\"\n  [style-vec comment-vec]\n  (let [minimum-col (minimum-column comment-vec)]\n    (reduce (partial change-start-column minimum-col) style-vec comment-vec)))\n\n(defn fzprint-align-inline-comments\n  \"Given the current style-vec, align all consecutive inline comments.\"\n  [options style-vec]\n  (dbg-pr options \"fzprint-align-inline-comments: style-vec:\" style-vec)\n  (let [style (:inline-align-style (:comment options))]\n    (if (= style :none)\n      style-vec\n      (let [comment-vec (cond (= style :aligned) (find-aligned-inline-comments\n                                                   style-vec)\n                              (= style :consecutive)\n                                (find-consecutive-inline-comments style-vec))\n            comment-vec-column (comment-vec-all-column style-vec comment-vec)]\n        (reduce align-comment-vec style-vec comment-vec-column)))))\n\n"]}