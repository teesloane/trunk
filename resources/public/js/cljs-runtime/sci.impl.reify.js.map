{"version":3,"sources":["sci/impl/reify.cljc"],"mappings":";AAMA,AAAA,uBAAA,+BAAAA,tDAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,0DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,4DAAA,5DAAME,uEAAOQ,EAAEA,MAAEC,KAAOC;AAAxB,AACE,IAAMK,sBAAiB,AAACC,0BAAWC,wBAAQP;IACrCK,0BAAiB,6CAAA,7CAACG,gFAAQ,AAACC,4CAAI,WAAAC;AAAA,AAAA,IAAAC,aAAAD;IAAAE,aAAA,AAAAV,cAAAS;IAAAE,eAAA,AAAApB,gBAAAmB;IAAAA,iBAAA,AAAAlB,eAAAkB;aAAAC,TAAMC;eAANF,XAAeG;AAAf,AAAA,0FACGD,OAAM,6CAAA,7CAACN,gFACK,AAACC,4CAAI,WAAKQ;AAAL,AAAA,OAAAD,cAAA,AAAAf,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KAAA,AAAA,2DAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,2BAAA,KAAA,IAAA,UAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,uEAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,4BAAA,KAAA,IAAA,uFAAA,KAAA,IAAA,hdACM,AAACX,gBAAMwB,gUAAW,AAACC,iBAAOD,wEAAQ,AAACE,gBAAMF;GAChDF;GACnBV;AANrC,AAAA,OAAAJ,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KAAA,AAAA,8EAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,6BAAA,KAAA,IAAA,jCAOyBC;;;AAR3B,CAAA,+CAAA,/CAAMf;;AAAN;AAAA,CAAA,yCAAA,WAAAC,pDAAMD;AAAN,AAAA,IAAAE,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAI,WAAA,AAAAF,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAK,WAAA,AAAAH,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAM,qBAAA;AAAA,AAAA,OAAAA,wDAAAL,SAAAG,SAAAC,SAAAL;;;AAAA,AAUA,6BAAA,7BAAM6B,kEACiBrB,KAAMM;AAD7B,AAeW,IAAAgB,aAA0B,AAAC5B,gBAAMY;iBAAjC,AAAAiB,4CAAAD,WAAA,IAAA,xEAAOE;eAAP,AAAAD,4CAAAD,WAAA,IAAA,tEAAiBN;AAAjB,AACE,OAACS,4BAAYD,WAAUR","names":["var_args","args__4824__auto__","len__4818__auto__","i__4819__auto__","argseq__4825__auto__","cljs.core/IndexedSeq","sci.impl.reify/reify","seq34266","G__34267","cljs.core/first","cljs.core/next","G__34268","G__34269","self__4805__auto__","_","_ctx","args","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","classes->methods","sci.impl.utils/split-when","cljs.core/symbol?","cljs.core.into","cljs.core.map","p__34272","vec__34273","seq__34274","first__34275","class","methods","cljs.core/vec","meth","cljs.core/second","cljs.core/nnext","sci.impl.reify/reify*","vec__34286","cljs.core.nth","interface","sci.impl.types/->Reified"],"sourcesContent":["(ns sci.impl.reify\n  {:no-doc true}\n  (:refer-clojure :exclude [reify])\n  (:require [sci.impl.types :as t]\n            [sci.impl.utils :refer [split-when]]))\n\n(defn reify [_ _ _ctx & args]\n  (let [classes->methods (split-when symbol? args)\n        classes->methods (into {} (map (fn [[class &  methods]]\n                                         [class (into {}\n                                                      (map (fn [meth]\n                                                             `['~(first meth) (fn ~(second meth) ~@(nnext meth))])\n                                                          methods))])\n                                       classes->methods))]\n    `(clojure.core/reify* ~classes->methods)))\n\n(defn reify* [#?(:clj ctx\n                 :cljs _ctx) classes->methods]\n  #?(:clj (let [ks (keys classes->methods)]\n            ;; NOTE: if the first thing in reify is a class, we assume all\n            ;; classes and no protocols. This should be addressed in a future version.\n            (if (class? (first ks))\n              (let [class-names (set (map #(symbol (.getName ^Class %)) ks))]\n                (if-let [factory (get-in ctx [:reify class-names])]\n                  (factory (zipmap class-names (vals classes->methods)))\n                  (throw (ex-info (str \"No reify factory for: \" class-names)\n                                  {:class class}))))\n              ;; So far we only supported reify-ing one protocol at a time. This\n              ;; should be addressed in a future version\n              (let [[interface methods] (first classes->methods)]\n                (t/->Reified interface methods))))\n     :cljs (let [[interface methods] (first classes->methods)]\n             (t/->Reified interface methods))))\n"]}