{"version":3,"sources":["sci/impl/core_protocols.cljc"],"mappings":"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","names":["js/sci","js/sci.impl","js/sci.impl.core-protocols","js/sci.impl.core-protocols.-deref","method-table__4701__auto__","cljs.core.atom","prefer-table__4702__auto__","method-cache__4703__auto__","cached-hierarchy__4704__auto__","hierarchy__4705__auto__","cljs.core.get","fexpr__31923","cljs.core/MultiFn","cljs.core.symbol","sci.impl.core-protocols/-deref","sci.impl.types/type-impl","ref","methods","sci.impl.types/getMethods","fexpr__31926","cljs.core/deref","sci.impl.core-protocols/deref*","x","sci.impl.core-protocols/cljs-core-ns","sci.impl.vars/->SciNamespace","sci.impl.core-protocols/deref-protocol","sci.impl.vars.new_var","js/sci.impl.core-protocols.-swap!","fexpr__31937","sci.impl.core-protocols/-swap!","js/sci.impl.core-protocols.-reset!","fexpr__31939","sci.impl.core-protocols/-reset!","f","fexpr__31943","a1","fexpr__31947","a2","fexpr__31948","args","cljs.core.apply","v","fexpr__31956","cljs.core/swap!","cljs.core/reset!","var_args","args__4824__auto__","len__4818__auto__","i__4819__auto__","argseq__4825__auto__","cljs.core/IndexedSeq","sci.impl.core-protocols/swap!*","seq31965","G__31966","cljs.core/first","cljs.core/next","G__31967","self__4805__auto__","sci.impl.core-protocols/reset!*","sci.impl.core-protocols/swap-protocol","sci.impl.core-protocols/reset-protocol"],"sourcesContent":["(ns sci.impl.core-protocols\n  {:no-doc true}\n  (:refer-clojure :exclude [deref -deref -swap! -reset!])\n  (:require [sci.impl.types :as types]\n            [sci.impl.vars :as vars]))\n\n\n;;;; IDeref\n\n(defmulti #?(:clj deref :cljs -deref) types/type-impl)\n\n(defmethod #?(:clj deref :cljs -deref) :sci.impl.protocols/reified [ref]\n  (let [methods (types/getMethods ref)]\n    ((get methods #?(:clj 'deref :cljs '-deref)) ref)))\n\n(defmethod #?(:clj deref :cljs -deref) :default [ref]\n  (clojure.core/deref ref))\n\n(defn deref*\n  ([x]\n   #?(:clj (deref x)\n      :cljs (-deref x)))\n  #?(:clj\n     ([x & args]\n      (apply clojure.core/deref x args))))\n\n#?(:clj\n   (def clj-lang-ns (vars/->SciNamespace 'clojure.lang nil)))\n#?(:cljs\n   (def cljs-core-ns (vars/->SciNamespace 'cljs.core nil)))\n\n(def deref-protocol\n  #?(:clj\n     (vars/new-var\n      'clojure.lang.IDeref\n      {:class clojure.lang.IDeref\n       :methods #{deref}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})\n     :cljs\n     (vars/new-var\n      'cljs.core.IDeref\n      {:methods #{-deref}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n;;;; end IDeref\n\n;;;; IAtom\n\n;; ;; You can use multiarity in multimethods\n;; (defmulti foo (fn [x & _] x))\n\n;; (defmethod foo :default [_ & _] \"DEFAULT VALUE DISPACHED\")\n\n;; ;; Like a standar multi-arity function\n;; (defmethod foo :bar\n;;   ([_ _] \"ONE ARGUMENT\")\n;;   ([_ _ _] \"TWO ARGUMENTs\")\n;;   ([_ _ _ _] \"THREE ARGUMENTs\")\n;;   ([_ _ _ _ & more] (cl-format nil \"~d ARGUMENTS\" (+ 3 (count more)))))\n\n(defmulti #?(:clj swap :cljs -swap!) types/type-impl)\n(defmulti #?(:clj reset :cljs -reset!) types/type-impl)\n#?(:clj (defmulti compareAndSet types/type-impl))\n#?(:clj (defmulti swapVals types/type-impl))\n#?(:clj (defmulti resetVals types/type-impl))\n\n;;;; Protocol methods\n\n(defmethod #?(:clj swap :cljs -swap!) :sci.impl.protocols/reified\n  ([ref f]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f)))\n  ([ref f a1]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f a1)))\n  ([ref f a1 a2]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f a1 a2)))\n  ([ref f a1 a2 & args]\n   (let [methods (types/getMethods ref)]\n     (apply (get methods #?(:clj 'swap :cljs '-swap!)) ref f a1 a2 args))))\n\n(defmethod #?(:clj reset :cljs -reset!) :sci.impl.protocols/reified [ref v]\n  (let [methods (types/getMethods ref)]\n    ((get methods #?(:clj 'reset :cljs '-reset!)) ref v)))\n\n#?(:clj\n   (defmethod compareAndSet :sci.impl.protocols/reified [ref old new]\n     (let [methods (types/getMethods ref)]\n       ((get methods 'compareAndSet) ref old new))))\n\n#?(:clj\n   (defmethod swapVals :sci.impl.protocols/reified\n     ([ref f]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f)))\n     ([ref f a1]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f a1)))\n     ([ref f a1 a2]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f a1 a2)))\n     ([ref f a1 a2 & args]\n      (let [methods (types/getMethods ref)]\n        (apply (get methods 'swapVals) ref f a1 a2 args)))))\n\n#?(:clj\n   (defmethod resetVals :sci.impl.protocols/reified [ref v]\n     (let [methods (types/getMethods ref)]\n       ((get methods 'resetVals) ref v))))\n\n;;;; Defaults\n\n(defmethod #?(:clj swap :cljs -swap!) :default [ref f & args]\n  ;; TODO: optimize arities\n  (apply clojure.core/swap! ref f args))\n\n(defmethod #?(:clj reset :cljs -reset!) :default [ref v]\n  (reset! ref v))\n\n#?(:clj\n   (defmethod compareAndSet :default [ref old new]\n     (compare-and-set! ref old new)))\n\n#?(:clj\n   (defmethod swapVals :default [ref & args]\n     (apply swap-vals! ref args)))\n\n#?(:clj\n   (defmethod resetVals :default [ref v]\n     (reset-vals! ref v)))\n\n;;;; Re-routing\n\n(defn swap!* [ref f & args]\n  ;; TODO: optimize arities - maybe test first how much this matters at all\n  ;; For CLJ I guess we can directly use the multimethods\n  (if args\n    (apply #?(:clj swap :cljs -swap!) ref f args)\n    (#?(:clj swap :cljs -swap!) ref f)))\n\n(defn reset!* [ref v]\n  (#?(:clj reset :cljs -reset!) ref v))\n\n#?(:clj\n   (defn compare-and-set!* [ref old new]\n     (compareAndSet ref old new)))\n\n#?(:clj\n   (defn swap-vals!* [ref f & args]\n     (apply swapVals ref f args)))\n\n#?(:clj\n   (defn reset-vals!* [ref v]\n     (resetVals ref v)))\n\n;;;; Protocol vars\n\n(def swap-protocol\n  #?(:clj\n     (vars/new-var\n      'clojure.lang.IAtom\n      {:class clojure.lang.IAtom\n       :methods #{swap, reset, compareAndSet}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})\n     :cljs\n     (vars/new-var\n      'cljs.core.ISwap\n      {:methods #{-swap!}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n#?(:cljs\n   (def reset-protocol\n     (vars/new-var\n      'cljs.core.IReset\n      {:methods #{-reset!}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n#?(:clj\n   (def iatom2-protocol\n     (vars/new-var\n      'clojure.lang.IAtom2\n      {:class clojure.lang.IAtom2\n       :methods #{swap, reset, compareAndSet, swapVals, resetVals}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})))\n\n;;;; end IAtom\n"]}