{"version":3,"sources":["zprint/rewrite.cljc"],"mappings":"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","names":["zprint.rewrite/prewalk-subtree","p?","f","zloc","loc","rewrite-clj.zip/end?","temp__5751__auto__","n","rewrite-clj.zip/next","zprint.rewrite/prewalk","G__30770","G__30771","rewrite-clj.zip/replace","G__30773","rewrite-clj.zip/root","G__30775","rewrite-clj.zip/node","zprint.zutil/edn*","zprint.rewrite/get-sortable","nloc","cljs.core._EQ_","rewrite-clj.zip/tag","rewrite-clj.zip/string","next-element","rewrite-clj.zip/right","rewrite-clj.zip/down","zprint.rewrite/sort-val","dep-val","dep-seq","out","cljs.core.conj","dep-count","cljs.core/count","sorted-seq","cljs.core.sort_by","new-loc","last-loc","new-z","cljs.core/first","new-node","rewrite-clj.parser/parse-string","replaced-loc","clojure.zip/replace","cljs.core/next","rewrite-clj.zip/up","zprint.rewrite/sort-down","G__30787","zprint.rewrite/sort-dependencies","caller","options","new-dep","p1__30795#","rewrite-clj.zip/sexpr"],"sourcesContent":["(ns zprint.rewrite\n  (:require\n    clojure.string\n    [zprint.zutil :as zu :refer [string tag zreplace sexpr edn*]]\n    [rewrite-clj.parser :as p]\n    [rewrite-clj.node :as n]\n    [rewrite-clj.zip :as z]\n    #?@(:cljs [[rewrite-clj.zip.base :as zb] [rewrite-clj.zip.whitespace :as zw]\n               [rewrite-clj.zip.move :as zm] [rewrite-clj.zip.removez :as zr]\n               [rewrite-clj.zip.editz :as ze] clojure.zip])))\n\n;;\n;; No prewalk in rewrite-cljs, so we'll do it ourselves here\n;; for both environments, so that we can lean on the clj testing\n;; for cljs.\n;;\n\n(defn- prewalk-subtree\n  [p? f zloc]\n  (loop [loc zloc]\n    (if (z/end? loc)\n      loc\n      (if (p? loc)\n        (if-let [n (f loc)]\n          (recur (z/next n))\n          (recur (z/next loc)))\n        (recur (z/next loc))))))\n\n(defn ^:no-doc prewalk\n  [zloc p? f]\n  (z/replace zloc\n             (z/root (prewalk-subtree p?\n                                      f\n                                      ; Make a zipper whose root is zloc\n                                      (some-> zloc\n                                              z/node\n                                              edn*)))))\n\n\n;;\n;; # Routines to modify zippers inside of zprint\n;;\n\n(defn ^:no-doc get-sortable\n  \"Given a zloc, get something out of it that is sortable.\"\n  [zloc]\n  (loop [nloc zloc]\n    (if (= (z/tag nloc) :token)\n      (str (z/string nloc)\n           (let [next-element (z/right nloc)]\n             (if (= (z/tag next-element) :token) (z/string next-element) \"\")))\n      (recur (z/down nloc)))))\n\n(defn ^:no-doc sort-val\n  \"Sort the everything in the vector to the right of zloc.\"\n  [zloc]\n  (let [dep-val zloc\n        dep-seq (loop [nloc zloc\n                       out []]\n                  (if nloc (recur (z/right nloc) (conj out nloc)) out))\n        #_(println \"sort-val: count:\" (count dep-seq))\n        dep-count (count dep-seq)\n        sorted-seq (sort-by get-sortable dep-seq)\n        #_(println \"sort-val: dep-seq:\" (mapv get-sortable dep-seq))\n        #_(println \"sort-val: sorted-seq:\" (mapv get-sortable sorted-seq))]\n    (loop [nloc zloc\n           new-loc sorted-seq\n           last-loc nil]\n      #_(println \"sort-val: loop: before:\" (z/string nloc))\n      #_(when nloc (println \"sort-val: loop: n/tag:\" (n/tag (z/node nloc))))\n      #_(when new-loc\n          (println \"sort-val: loop: after:\" (n/string (z/node (first new-loc))))\n          (println \"sort-val: loop: n/tag:\" (n/tag (z/node (first new-loc)))))\n      (if new-loc\n        (let [new-z (first new-loc)\n              ; rewrite-cljs doesn't handle z/node for :uneval\n              ; so we will get an :uneval node a different way\n              new-node (if (= (z/tag new-z) :uneval)\n                         (p/parse-string (z/string new-z))\n                         (z/node new-z))\n              ; use clojure.zip for cljs, since the z/replace has\n              ; a built-in coerce, which doesn't work for an :uneval\n              replaced-loc #?(:clj (z/replace nloc new-node)\n                              :cljs (clojure.zip/replace nloc new-node))]\n          #_(println \"sort-val: loop: replaced-loc n/tag:\"\n                     (n/tag (z/node replaced-loc)))\n          (recur (z/right replaced-loc) (next new-loc) replaced-loc))\n        (z/up last-loc)))))\n\n(defn ^:no-doc sort-down\n  \"Do a down and a sort-val\"\n  [zloc]\n  (sort-val (z/down (z/right zloc))))\n\n(defn sort-dependencies\n  \"Reorder the dependencies in a project.clj file.\"\n  [caller options zloc]\n  (let [new-dep (prewalk zloc\n                         #(and (= (z/tag %1) :token)\n                               (= (z/sexpr %1) :dependencies))\n                         sort-down)]\n    new-dep))\n"]}