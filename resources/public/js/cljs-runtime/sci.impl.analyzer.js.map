{"version":3,"sources":["sci/impl/analyzer.cljc"],"mappings":"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","names":["sci.impl.analyzer/special-syms","sci.impl.analyzer/throw-error-with-location","msg","node","sci.impl.utils.throw_error_with_location","sci.impl.analyzer/macroexpand-1","ctx","expr","original-expr","cljs.core/seq?","op","cljs.core/first","cljs.core/Symbol","cljs.core.get","cljs.core/contains?","G__40107","G__40108","sci.impl.analyzer/analyze","cljs.core.assoc","f","sci.impl.resolve.resolve_symbol","cljs.core/deref","and__4210__auto__","sci.impl.vars/var?","sci.impl.vars/isMacro","sci.impl.utils/macro?","sci.impl.utils/needs-ctx","G__40109","cljs.core/meta","cljs.core.partial","cljs.core.apply","cljs.core/rest","sci.impl.analyzer/macroexpand","form","ex","cljs.core/vreset!","sci.impl.utils/macroexpand*","sci.impl.utils/macroexpand-1*","sci.impl.analyzer/analyze-children","children","p1__40111#","cljs.core.mapv","sci.impl.analyzer/maybe-destructured","params","body","cljs.core/every?","cljs.core/symbol?","new-params","cljs.core/with-meta","lets","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/next","cljs.core.conj","gparam","cljs.core.gensym","p__40114","p__40115","map__40116","cljs.core/--destructure-map","fn-expr","vec__40117","seq__40118","first__40119","sci.impl.analyzer/expand-fn-args+body","fn-name","binding-vector","body-exprs","macro?","cljs.core/vector?","map__40120","cljs.core.into","fixed-args","p1__40112#","cljs.core.take_while","cljs.core.not_EQ_","fixed-arity","cljs.core/count","var-arg-name","cljs.core/second","p1__40113#","cljs.core.drop_while","next-body","conds","e","cljs.core/map?","or__4212__auto__","pre","post","cljs.core/vec","cljs.core.map","c","cljs.core.update","cljs.core/merge","cljs.core/zipmap","cljs.core.repeat","sci.impl.analyzer/analyzed-fn-meta","m","meta-needs-eval?","sci.impl.utils/mark-eval","p__40144","vec__40145","seq__40146","first__40147","sci.impl.analyzer/expand-fn","_fn","name?","cljs.core/cons","bodies","cljs.core/assoc-in","analyzed-bodies","cljs.core.reduce","p__40151","map__40152","max-fixed","min-varargs","acc","arglist","new-min-varargs","cljs.core/not","x__4295__auto__","y__4296__auto__","cljs.core/conj","arities","arglists","fn-meta","ana-fn-meta","cljs.core.dissoc","sci.impl.analyzer/expand-let*","destructured-let-bindings","exprs","vec__40292","cljs.core.nth","new-let-bindings","p__40295","p__40296","vec__40297","vec__40300","binding-name","binding-value","v","cljs.core/assoc","cljs.core.partition","sci.impl.evaluator/eval-let","sci.impl.utils/evaluate","p__40306","vec__40307","seq__40308","first__40309","sci.impl.analyzer/expand-let","_let","let-bindings","sci.impl.destructure/destructure","sci.impl.analyzer/expand-def","vec__40311","_def","var-name","?docstring","?init","G__40318","G__40319","sci.impl.analyzer/expand-declare","cljs.core/simple-symbol?","arg-count","docstring","cljs.core._EQ_","expected-arg-count","js/Error","init","sci.impl.vars/current-ns","sci.impl.utils.mark_eval_call","p__40322","vec__40323","seq__40324","first__40325","sci.impl.analyzer/expand-defn","G__40327","G__40328","vec__40329","cljs.core/name","pre-body","cljs.core/split-with","cljs.core.comp","cljs.core/sequential?","_","cljs.core/empty?","temp__5753__auto__","ds","meta-map","cljs.core/last","G__40332","G__40333","cljs.core.merge","fn-body","G__40334","sci.impl.analyzer/expand-loop","vec__40344","bv","arg-names","cljs.core.take_nth","init-vals","syms","cljs.core.repeatedly","bv1","cljs.core/vector","bv2","cljs.core/cat","cljs.core.interleave","cljs.core/nnext","expansion","cljs.core.list_STAR_","sci.impl.analyzer/expand-lazy-seq","G__40349","G__40350","p__40355","vec__40356","seq__40357","first__40358","sci.impl.analyzer/expand-if","_if","G__40359","vec__40360","cond","then","else","sci.impl.evaluator/eval-if","sci.impl.analyzer/expand-case","G__40367","G__40368","clauses","match-clauses","result-clauses","default","cljs.core/odd?","G__40369","G__40370","cases","assoc-new","k","case-map","ret-map","vec__40374","seq__40375","first__40376","cljs.core/list?","ret","p__40381","vec__40382","seq__40383","first__40384","sci.impl.analyzer/expand-try","_try","vec__40385","catches","finally","catch-exprs","finally-expr","G__40391","G__40392","vec__40393","seq__40394","first__40395","binding","temp__5751__auto__","clazz","sci.impl.interop/resolve-class","G__40396","G__40397","G__40402","G__40403","p__40408","vec__40409","seq__40410","first__40411","_declare","names","cljs.core.swap_BANG_","env","cnn","sci.impl.vars/current-ns-name","cljs.core.update_in","current-ns","name","x","prev-ns","G__40412","current-ns-name","sci.impl.vars/getName","G__40413","sci.impl.vars/->SciVar","cljs.core.symbol","sci.impl.vars/current-file","p__40422","vec__40423","seq__40424","first__40425","sci.impl.analyzer/expand-dot","_dot","instance-expr","method-expr","args","_expr","vec__40426","seq__40427","first__40428","sci.impl.utils/vary-meta*","t","sci.impl.records/resolve-record-class","res","sci.impl.analyzer/expand-dot**","p__40438","vec__40439","seq__40440","first__40441","sci.impl.analyzer/expand-dot*","method-name","obj","cljs.core.subs","p__40442","vec__40443","seq__40444","first__40445","sci.impl.analyzer/expand-new","_new","class-sym","map__40446","constructor","_opts","sci.impl.interop/resolve-class-opts","record","p__40447","vec__40449","seq__40450","first__40451","sci.impl.analyzer/expand-constructor","constructor-sym","constructor-name","p__40460","vec__40461","seq__40462","first__40463","sci.impl.analyzer/analyze-ns-form","_ns","ns-name","cljs.core.pr_str","vec__40464","vec__40467","fexpr","attr-map","sci.impl.utils/set-namespace!","vec__40479","seq__40480","first__40481","G__40482","cljs.core/Keyword","p__40483","vec__40484","sci.impl.analyzer/analyze-var","p__40492","vec__40493","sci.impl.analyzer/analyze-set!","sci.impl.types/getVal","sci.impl.analyzer/analyze-call","top-level?","special-sym","sci.impl.resolve/check-permission!","f-meta","eval?","sci.impl.utils/ana-macros","G__40507","sci.impl.for-macro/expand-for","G__40508","G__40509","sci.impl.doseq-macro/expand-doseq","e40515","needs-ctx?","expanded","sci.impl.types/->EvalForm","sci.impl.utils/rethrow-with-location-of-node","sci.impl.analyzer/constant-colls","var_args","G__40521","sci.impl.analyzer.analyze","sci.impl.utils/constant?","sci.impl.types/->EvalVar","sci.impl.utils/merge-meta","cljs.core/record?","ks","cljs.core/keys","vs","cljs.core/vals","constant-map?","analyzed-map","analyzed-meta","cljs.core/set?","constant-coll?","analyzed-coll","cljs.core/empty"],"sourcesContent":["(ns sci.impl.analyzer\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-all macroexpand-1])\n  (:require\n   #?(:clj [clojure.string :as str])\n   [sci.impl.destructure :refer [destructure]]\n   [sci.impl.doseq-macro :refer [expand-doseq]]\n   [sci.impl.evaluator :as eval]\n   [sci.impl.for-macro :refer [expand-for]]\n   [sci.impl.interop :as interop]\n   [sci.impl.records :as records]\n   [sci.impl.resolve :as resolve]\n   [sci.impl.types :as types]\n   [sci.impl.utils :as utils :refer\n    [mark-eval mark-eval-call constant?\n     rethrow-with-location-of-node\n     merge-meta set-namespace!\n     macro? ana-macros]]\n   [sci.impl.vars :as vars])\n  #?(:clj (:import [sci.impl Reflector])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; derived from (keys (. clojure.lang.Compiler specials))\n;; (& monitor-exit case* try reify* finally loop* do letfn* if clojure.core/import* new deftype* let* fn* recur set! . var quote catch throw monitor-enter def)\n(def special-syms '#{try finally do if new recur quote catch throw def . var set!})\n\n(defn- throw-error-with-location [msg node]\n  (utils/throw-error-with-location msg node {:phase \"analysis\"}))\n\n(declare analyze analyze-call)\n\n;;;; Macros\n\n(defn macroexpand-1 [ctx expr]\n  (let [original-expr expr]\n    (if (seq? expr)\n      (let [op (first expr)]\n        (if (symbol? op)\n          (cond (get special-syms op) expr\n                (contains? #{'for} op) (analyze (assoc ctx :sci.impl/macroexpanding true)\n                                                    expr)\n                :else\n                (let [f (resolve/resolve-symbol ctx op true)\n                      f (if (and (vars/var? f)\n                                 (vars/isMacro f))\n                          @f f)]\n                  (if (macro? f)\n                    (let [f (if (identical? utils/needs-ctx (some-> f meta :sci.impl/op))\n                              (partial f ctx)\n                              f)]\n                      (apply f original-expr (:bindings ctx) (rest expr)))\n                    expr)))\n          expr))\n      expr)))\n\n(defn macroexpand\n  [ctx form]\n  (let [ex (macroexpand-1 ctx form)]\n    (if (identical? ex form)\n      form\n      (macroexpand ctx ex))))\n\n(vreset! utils/macroexpand* macroexpand)\n(vreset! utils/macroexpand-1* macroexpand-1)\n\n;;;; End macros\n\n(defn analyze-children [ctx children]\n  (mapv #(analyze ctx %) children))\n\n(defn maybe-destructured\n  [params body]\n  (if (every? symbol? params)\n    {:params params\n     :body body}\n    (loop [params params\n           new-params (with-meta [] (meta params))\n           lets []]\n      (if params\n        (if (symbol? (first params))\n          (recur (next params) (conj new-params (first params)) lets)\n          (let [gparam (gensym \"p__\")]\n            (recur (next params) (conj new-params gparam)\n                   (-> lets (conj (first params)) (conj gparam)))))\n        {:params new-params\n         :body [`(let ~lets\n                   ~@body)]}))))\n\n(defn expand-fn-args+body [{:keys [:fn-expr] :as ctx} fn-name [binding-vector & body-exprs] macro?]\n  (when-not binding-vector\n    (throw-error-with-location \"Parameter declaration missing.\" fn-expr))\n  (when-not (vector? binding-vector)\n    (throw-error-with-location \"Parameter declaration should be a vector\" fn-expr))\n  (let [binding-vector (if macro? (into ['&form '&env] binding-vector)\n                           binding-vector)\n        fixed-args (take-while #(not= '& %) binding-vector)\n        fixed-arity (count fixed-args)\n        var-arg-name (second (drop-while #(not= '& %) binding-vector))\n        next-body (next body-exprs)\n        conds (when next-body\n                (let [e (first body-exprs)]\n                  (when (map? e) e)))\n        body-exprs (if conds next-body body-exprs)\n        conds (or conds (meta binding-vector))\n        pre (:pre conds)\n        post (:post conds)\n        body-exprs (if post\n                     `((let [~'% ~(if (< 1 (count body-exprs))\n                                    `(do ~@body-exprs)\n                                    (first body-exprs))]\n                         ~@(map (fn* [c] `(assert ~c)) post)\n                         ~'%))\n                     body-exprs)\n        body-exprs (if pre\n                     (concat (map (fn* [c] `(assert ~c)) pre)\n                             body-exprs)\n                     body-exprs)\n        {:keys [:params :body]} (maybe-destructured binding-vector body-exprs)\n        ctx (update ctx :bindings merge (zipmap params\n                                                (repeat nil)))\n        body (analyze-children ctx body)]\n    #:sci.impl{:body body\n               :params params\n               :fixed-arity fixed-arity\n               :var-arg-name var-arg-name\n               :fn-name fn-name}))\n\n(defn analyzed-fn-meta [ctx m]\n  (let [;; seq expr has location info with 2 keys\n        meta-needs-eval? (> (count m) 2)\n        m (if meta-needs-eval? (mark-eval (analyze ctx m))\n              m)]\n    m))\n\n(defn expand-fn [ctx [_fn name? & body :as fn-expr] macro?]\n  (let [ctx (assoc ctx :fn-expr fn-expr)\n        fn-name (if (symbol? name?)\n                  name?\n                  nil)\n        body (if fn-name\n               body\n               (cons name? body))\n        ;; fn-name (or fn-name (gensym* \"fn\"))\n        bodies (if (seq? (first body))\n                 body\n                 [body])\n        ctx (if fn-name (assoc-in ctx [:bindings fn-name] nil)\n                ctx)\n        analyzed-bodies (reduce\n                         (fn [{:keys [:max-fixed :min-varargs] :as acc} body]\n                           (let [arglist (first body)\n                                 body (expand-fn-args+body ctx fn-name body macro?)\n                                 body (assoc body :sci.impl/arglist arglist)\n                                 var-arg-name (:sci.impl/var-arg-name body)\n                                 fixed-arity (:sci.impl/fixed-arity body)\n                                 new-min-varargs (when var-arg-name fixed-arity)]\n                             (when (and var-arg-name min-varargs)\n                               (throw-error-with-location \"Can't have more than 1 variadic overload\" fn-expr))\n                             (when (and (not var-arg-name) min-varargs (> fixed-arity min-varargs))\n                               (throw-error-with-location\n                                \"Can't have fixed arity function with more params than variadic function\" fn-expr))\n                             (-> acc\n                                 (assoc :min-varargs new-min-varargs\n                                        :max-fixed (max (:sci.impl/fixed-arity body)\n                                                        max-fixed))\n                                 (update :bodies conj body)\n                                 (update :arglists conj arglist))))\n                         {:bodies []\n                          :arglists []\n                          :min-var-args nil\n                          :max-fixed -1} bodies)\n        arities (:bodies analyzed-bodies)\n        arglists (:arglists analyzed-bodies)\n        fn-meta (meta fn-expr)\n        ana-fn-meta (analyzed-fn-meta ctx fn-meta)\n        fn-meta (when-not (identical? fn-meta ana-fn-meta)\n                  ;; fn-meta contains more than only location info\n                  (-> ana-fn-meta (dissoc :line :end-line :column :end-column)))]\n    (with-meta #:sci.impl{:fn-bodies arities\n                          :fn-name fn-name\n                          :arglists arglists\n                          :fn true\n                          :fn-meta fn-meta}\n      {:sci.impl/op :fn})))\n\n(defn expand-let*\n  [ctx destructured-let-bindings exprs]\n  (let [[ctx new-let-bindings]\n        (reduce\n         (fn [[ctx new-let-bindings] [binding-name binding-value]]\n           (let [v (analyze ctx binding-value)]\n             [(update ctx :bindings assoc binding-name v)\n              (conj new-let-bindings binding-name v)]))\n         [ctx []]\n         (partition 2 destructured-let-bindings))\n        body (analyze-children ctx exprs)]\n    (with-meta\n      (fn [ctx]\n        (eval/eval-let ctx new-let-bindings body))\n      {:sci.impl/op utils/evaluate})))\n\n(defn expand-let\n  \"The let macro from clojure.core\"\n  [ctx [_let let-bindings  & exprs]]\n  (let [let-bindings (destructure let-bindings)]\n    (expand-let* ctx let-bindings exprs)))\n\n(declare expand-declare)\n\n(defn expand-def\n  [ctx expr]\n  (let [[_def var-name ?docstring ?init] expr]\n    (expand-declare ctx [nil var-name])\n    (when-not (simple-symbol? var-name)\n      (throw-error-with-location \"Var name should be simple symbol.\" expr))\n    (let [arg-count (count expr)\n          docstring (when (and (= 4 arg-count)\n                               (string? ?docstring))\n                      ?docstring)\n          expected-arg-count (if docstring 4 3)]\n      (when-not (<= arg-count expected-arg-count)\n        (throw (new #?(:clj  IllegalArgumentException\n                       :cljs js/Error)\n                    \"Too many arguments to def\")))\n      (let [init (if docstring ?init ?docstring)\n            init (if (= 2 arg-count)\n                   :sci.impl/var.unbound\n                   (analyze ctx init))\n            m (meta var-name)\n            m (analyze ctx m)\n            m (assoc m :ns @vars/current-ns)\n            m (if docstring (assoc m :doc docstring) m)\n            var-name (with-meta var-name m)]\n        (mark-eval-call (list 'def var-name init))))))\n\n(defn expand-defn [ctx [op fn-name & body :as expr]]\n  (when-not (simple-symbol? fn-name)\n    (throw-error-with-location \"Var name should be simple symbol.\" expr))\n  (expand-declare ctx [nil fn-name])\n  (let [macro? (= \"defmacro\" (name op))\n        [pre-body body] (split-with (comp not sequential?) body)\n        _ (when (empty? body)\n            (throw-error-with-location \"Parameter declaration missing.\" expr))\n        docstring (when-let [ds (first pre-body)]\n                    (when (string? ds) ds))\n        meta-map (when-let [m (last pre-body)]\n                   (when (map? m) m))\n        meta-map (analyze ctx (merge (meta fn-name) (meta expr) meta-map))\n        fn-body (with-meta (cons 'fn body)\n                  (meta expr))\n        f (expand-fn ctx fn-body macro?)\n        arglists (seq (:sci.impl/arglists f))\n        meta-map (assoc meta-map\n                        :ns @vars/current-ns\n                        :arglists arglists)\n        fn-name (with-meta fn-name\n                  (cond-> meta-map\n                    docstring (assoc :doc docstring)\n                    macro? (assoc :macro true)))\n        f (assoc f\n                 :sci/macro macro?\n                 :sci.impl/fn-name fn-name\n                 :sci.impl/var true)]\n    (mark-eval-call (list 'def fn-name f))))\n\n(defn expand-loop\n  [ctx expr]\n  (let [bv (second expr)\n        arg-names (take-nth 2 bv)\n        init-vals (take-nth 2 (rest bv))\n        [bv syms] (if (every? symbol? arg-names)\n                    [bv arg-names]\n                    (let [syms (repeatedly (count arg-names) #(gensym))\n                          bv1 (map vector syms init-vals)\n                          bv2  (map vector arg-names syms)]\n                      [(into [] cat (interleave bv1 bv2)) syms]))\n        body (nnext expr)\n        expansion (list 'let bv\n                        (list* `(fn ~(vec arg-names) ~@body)\n                               syms))]\n    (analyze ctx expansion)))\n\n(defn expand-lazy-seq\n  [ctx expr]\n  (let [body (rest expr)]\n    (mark-eval-call\n     (list `lazy-seq\n           (analyze ctx\n                    ;; expand-fn will take care of the analysis of the body\n                    (list 'fn [] (cons 'do body)))))))\n\n(defn expand-if\n  [ctx [_if & exprs :as expr]]\n  (case (count exprs)\n    (0 1) (throw-error-with-location \"Too few arguments to if\" expr)\n    (2 3) (let [[cond then else] (analyze-children ctx exprs)]\n            (with-meta\n              (fn [ctx]\n                (eval/eval-if ctx cond then else))\n              {:sci.impl/op utils/evaluate}))\n    (throw-error-with-location \"Too many arguments to if\" expr)))\n\n(defn expand-case\n  [ctx expr]\n  (let [v (analyze ctx (second expr))\n        clauses (nnext expr)\n        match-clauses (take-nth 2 clauses)\n        result-clauses (analyze-children ctx (take-nth 2 (rest clauses)))\n        default (when (odd? (count clauses))\n                  [:val (analyze ctx (last clauses))])\n        cases (interleave match-clauses result-clauses)\n        assoc-new (fn [m k v]\n                    (if-not (contains? m k)\n                      (assoc m k v)\n                      (throw-error-with-location (str \"Duplicate case test constant \" k)\n                                                 expr)))\n        case-map (loop [cases (seq cases)\n                        ret-map {}]\n                   (if cases\n                     (let [[k v & cases] cases]\n                       (if (list? k)\n                         (recur\n                          cases\n                          (reduce (fn [acc k]\n                                    (assoc-new acc k v))\n                                  ret-map\n                                  k))\n                         (recur\n                          cases\n                          (assoc-new ret-map k v))))\n                     ret-map))\n        ret (mark-eval-call (list 'case\n                                  {:case-map case-map\n                                   :case-val v\n                                   :case-default default}\n                                  default))]\n    (mark-eval-call ret)))\n\n(defn expand-try\n  [ctx [_try & body]]\n  (let [[body-exprs\n         catches\n         finally]\n        (loop [exprs #_[expr & exprs :as all-exprs] (seq body)\n               body-exprs []\n               catch-exprs []\n               finally-expr nil]\n          (if exprs\n            (let [expr (first exprs)\n                  exprs (next exprs)]\n              (cond (and (seq? expr) (= 'catch (first expr)))\n                    (recur exprs body-exprs (conj catch-exprs expr) finally-expr)\n                    (and (not exprs) (and (seq? expr) (= 'finally (first expr))))\n                    [body-exprs catch-exprs expr]\n                    :else\n                    ;; TODO: cannot add body expression when catch is not empty\n                    ;; TODO: can't have finally as non-last expression\n                    (recur exprs (conj body-exprs expr) catch-exprs finally-expr)))\n            [body-exprs catch-exprs finally-expr]))\n        body (analyze ctx (cons 'do body-exprs))\n        catches (mapv (fn [c]\n                        (let [[_ ex binding & body] c]\n                          (if-let [clazz (interop/resolve-class ctx ex)]\n                            {:class clazz\n                             :binding binding\n                             :body (analyze (assoc-in ctx [:bindings binding] nil)\n                                            (cons 'do body))}\n                            (throw-error-with-location (str \"Unable to resolve classname: \" ex) ex))))\n                      catches)\n        finally (when finally\n                  (analyze ctx (cons 'do (rest finally))))]\n    (with-meta\n      {:sci.impl/try\n       {:body body\n        :catches catches\n        :finally finally}}\n      {:sci.impl/op :try})))\n\n(defn expand-declare [ctx [_declare & names :as expr]]\n  (swap! (:env ctx)\n         (fn [env]\n           (let [cnn (vars/current-ns-name)]\n             (update-in env [:namespaces cnn]\n                        (fn [current-ns]\n                          (reduce (fn [acc name]\n                                    (if-let [x (.get ^java.util.Map acc name)]\n                                      (if-let [prev-ns (some-> x meta :ns)]\n                                        (let [current-ns-name (vars/current-ns-name)]\n                                          (if-not (= (vars/getName prev-ns)\n                                                     current-ns-name)\n                                            (throw-error-with-location\n                                             (str name \" already refers to \"\n                                                  x \" in namespace \"\n                                                  current-ns-name)\n                                             expr)\n                                            ;; when the previous bound thing\n                                            ;; didn't have an ns, just assume\n                                            ;; things are ok to redefine\n                                            acc))\n                                        ;; declare does not override an existing var\n                                        acc)\n                                      (assoc acc name\n                                             (doto (vars/->SciVar nil (symbol (str cnn)\n                                                                              (str name))\n                                                                  (assoc (meta name)\n                                                                         :name name\n                                                                         :ns @vars/current-ns\n                                                                         :file @vars/current-file)\n                                                                  false)\n                                               (vars/unbind)))))\n                                  current-ns\n                                  names))))))\n  nil)\n\n;;;; Interop\n\n(defn expand-dot [ctx [_dot instance-expr method-expr & args :as _expr]]\n  (let [[method-expr & args] (if (seq? method-expr) method-expr\n                                 (cons method-expr args))\n        instance-expr (analyze ctx instance-expr)\n        instance-expr (utils/vary-meta*\n                       instance-expr\n                       (fn [m]\n                         (if-let [t (:tag m)]\n                           (let [clazz (or (interop/resolve-class ctx t)\n                                           (records/resolve-record-class ctx t)\n                                           (throw-error-with-location\n                                            (str \"Unable to resolve classname: \" t) t))]\n                             (assoc m :tag-class clazz))\n                           m)))\n        method-expr (name method-expr)\n        args (when args (analyze-children ctx args))\n        res #?(:clj (if (class? instance-expr)\n                      (if (nil? args)\n                        (if (str/starts-with? method-expr \"-\")\n                          (with-meta [instance-expr (subs method-expr 1)]\n                            {:sci.impl/op :static-access})\n                          ;; https://clojure.org/reference/java_interop\n                          ;; If the second operand is a symbol and no args are\n                          ;; supplied it is taken to be a field access - the\n                          ;; name of the field is the name of the symbol, and\n                          ;; the value of the expression is the value of the\n                          ;; field, unless there is a no argument public method\n                          ;; of the same name, in which case it resolves to a\n                          ;; call to the method.\n                          (if-let [_\n                                   (try (Reflector/getStaticField ^Class instance-expr ^String method-expr)\n                                        (catch IllegalArgumentException _ nil))]\n                            (with-meta [instance-expr method-expr]\n                              {:sci.impl/op :static-access})\n                            (mark-eval-call\n                             `(~(with-meta [instance-expr method-expr]\n                                  {:sci.impl/op :static-access}) ~@args))))\n                        (mark-eval-call\n                         `(~(with-meta [instance-expr method-expr]\n                              {:sci.impl/op :static-access}) ~@args)))\n                      (mark-eval-call `(~'. ~instance-expr ~method-expr ~args)))\n               :cljs (mark-eval-call `(~'. ~instance-expr ~method-expr ~args)))]\n    res))\n\n(defn expand-dot**\n  \"Expands (. x method)\"\n  [ctx expr]\n  (when (< (count expr) 3)\n    (throw (new #?(:clj IllegalArgumentException :cljs js/Error)\n                \"Malformed member expression, expecting (.member target ...)\")))\n  (expand-dot ctx expr))\n\n(defn expand-dot*\n  \"Expands (.foo x)\"\n  [ctx [method-name obj & args :as expr]]\n  (when (< (count expr) 2)\n    (throw (new #?(:clj IllegalArgumentException :cljs js/Error)\n                \"Malformed member expression, expecting (.member target ...)\")))\n  (expand-dot ctx (list '. obj (cons (symbol (subs (name method-name) 1)) args))))\n\n(defn expand-new [ctx [_new class-sym & args :as _expr]]\n  (if-let [#?(:clj {:keys [:class] :as _opts}\n              :cljs {:keys [:constructor] :as _opts}) (interop/resolve-class-opts ctx class-sym)]\n    (let [args (analyze-children ctx args)] ;; analyze args!\n      (mark-eval-call (list 'new #?(:clj class :cljs constructor) args)))\n    (if-let [record (records/resolve-record-class ctx class-sym)]\n      (let [args (analyze-children ctx args)]\n        (mark-eval-call (list* (:sci.impl.record/constructor (meta record)) args)))\n      (throw-error-with-location (str \"Unable to resolve classname: \" class-sym) class-sym))))\n\n(defn expand-constructor [ctx [constructor-sym & args]]\n  (let [constructor-name (name constructor-sym)\n        class-sym (with-meta (symbol (subs constructor-name 0\n                                           (dec (count constructor-name))))\n                    (meta constructor-sym))]\n    (expand-new ctx (with-meta (list* 'new class-sym args)\n                      (meta constructor-sym)))))\n\n;;;; End interop\n\n;;;; Namespaces\n\n(defn analyze-ns-form [ctx [_ns ns-name & exprs]]\n  (when-not (symbol? ns-name)\n    (throw (new #?(:clj IllegalArgumentException\n                   :cljs js/Error)\n                (str \"Namespace name must be symbol, got: \" (pr-str ns-name)))))\n  (let [[docstring exprs]\n        (let [fexpr (first exprs)]\n          (if (string? fexpr)\n            [fexpr (next exprs)]\n            [nil exprs]))\n        ;; skip attr-map\n        [attr-map exprs]\n        (let [m (first exprs)]\n          (if (map? m)\n            [m (next exprs)]\n            [nil exprs]))\n        attr-map (if docstring\n                   (assoc attr-map :doc docstring)\n                   attr-map)]\n    (set-namespace! ctx ns-name attr-map)\n    (loop [exprs exprs\n           ret []]\n      (if exprs\n        (let [[k & args :as expr] (first exprs)]\n          (case k\n            (:require :use)\n            (recur (next exprs)\n                   (conj ret\n                         (mark-eval-call\n                          (with-meta (list* (symbol (name k)) args)\n                            (meta expr)))))\n            :import (recur (next exprs) (conj ret (mark-eval-call\n                                                   (with-meta (list* 'import args)\n                                                     (meta expr)))))\n            :refer-clojure (recur (next exprs)\n                                  (conj ret\n                                        (mark-eval-call\n                                         (with-meta (list* 'refer 'clojure.core args)\n                                           (meta expr)))))\n            :gen-class ;; ignore\n            (recur (next exprs) ret)))\n        (mark-eval-call (list* 'do ret))))))\n\n;;;; End namespaces\n\n\n;;;; Vars\n\n(defn analyze-var [ctx [_ var-name]]\n  (resolve/resolve-symbol (assoc ctx :sci.impl/prevent-deref true) var-name))\n\n(defn analyze-set! [ctx [_ obj v]]\n  (let [obj (analyze ctx obj)\n        v (analyze ctx v)\n        obj (types/getVal obj)]\n    (mark-eval-call (list 'set! obj v))))\n\n;;;; End vars\n\n(defn analyze-call [ctx expr top-level?]\n  (let [f (first expr)]\n    (if (symbol? f)\n      (let [;; in call position Clojure prioritizes special symbols over\n            ;; bindings\n            special-sym (get special-syms f)\n            _ (when special-sym (resolve/check-permission! ctx special-sym f nil))\n            f (or special-sym\n                  (resolve/resolve-symbol ctx f true))\n            #_#_f (if (and (vars/var? f)\n                           (vars/isMacro f))\n                    f f)\n            f-meta (meta f)\n            eval? (and f-meta (:sci.impl/op f-meta))]\n        (cond (and f-meta (::static-access f-meta))\n              (expand-dot** ctx (list* '. (first f) (second f) (rest expr)))\n              (and (not eval?) ;; the symbol is not a binding\n                   (or\n                    special-sym\n                    (contains? ana-macros f)))\n              (case f\n                ;; we treat every subexpression of a top-level do as a separate\n                ;; analysis/interpretation unit so we hand this over to the\n                ;; interpreter again, which will invoke analysis + evaluation on\n                ;; every sub expression\n                do (mark-eval-call (cons 'do\n                                         (analyze-children ctx (rest expr))))\n                let (expand-let ctx expr)\n                (fn fn*) (expand-fn ctx expr false)\n                def (expand-def ctx expr)\n                ;; NOTE: defn / defmacro aren't implemented as normal macros yet\n                (defn defmacro) (let [ret (expand-defn ctx expr)]\n                                  ret)\n                ;; TODO: implement as normal macro in namespaces.cljc\n                loop (expand-loop ctx expr)\n                lazy-seq (expand-lazy-seq ctx expr)\n                for (let [res (expand-for ctx expr)]\n                      (if (:sci.impl/macroexpanding ctx)\n                        res\n                        (analyze ctx res)))\n                doseq (analyze ctx (expand-doseq ctx expr))\n                if (expand-if ctx expr)\n                case (expand-case ctx expr)\n                try (expand-try ctx expr)\n                declare (expand-declare ctx expr)\n                expand-dot* (expand-dot* ctx expr)\n                . (expand-dot** ctx expr)\n                expand-constructor (expand-constructor ctx expr)\n                new (expand-new ctx expr)\n                ns (analyze-ns-form ctx expr)\n                var (analyze-var ctx expr)\n                set! (analyze-set! ctx expr)\n                (import quote) (mark-eval-call expr) ;; don't analyze children\n                ;; else:\n                (mark-eval-call (cons f (analyze-children ctx (rest expr)))))\n              :else\n              (try\n                (if (macro? f)\n                  (let [needs-ctx? (identical? utils/needs-ctx\n                                               (:sci.impl/op (meta f)))\n                        v (if needs-ctx?\n                            (apply f expr\n                                   (:bindings ctx)\n                                   ctx\n                                   (rest expr))\n                            (apply f expr\n                                   (:bindings ctx) (rest expr)))\n                        expanded (cond (:sci.impl/macroexpanding ctx) v\n                                       (and top-level? (seq? v) (= 'do (first v)))\n                                       ;; hand back control to eval-form for\n                                       ;; interleaved analysis and eval\n                                       (types/->EvalForm v)\n                                       :else (analyze ctx v))]\n                    expanded)\n                  (if-let [f (:sci.impl/inlined f-meta)]\n                    (mark-eval-call (cons f (analyze-children ctx (rest expr)))\n                                    :sci.impl/f-meta f-meta)\n                    (mark-eval-call (cons f (analyze-children ctx (rest expr))))))\n                (catch #?(:clj Exception :cljs js/Error) e\n                  (rethrow-with-location-of-node ctx e\n                                                 ;; adding metadata for error reporting\n                                                 (mark-eval-call\n                                                  (with-meta (cons f (rest expr))\n                                                    (meta expr))))))))\n      (let [ret (mark-eval-call (analyze-children ctx expr))]\n        ret))))\n\n(def ^:const constant-colls true) ;; see GH #452\n\n(defn analyze\n  ([ctx expr]\n   (analyze ctx expr false))\n  ([ctx expr top-level?]\n   ;; (prn :ana expr)\n   (let [m (meta expr)\n         ret (cond (constant? expr) expr ;; constants do not carry metadata\n                   (symbol? expr) (let [v (resolve/resolve-symbol ctx expr false)]\n                                    (cond (constant? v) v\n                                          (vars/var? v)\n                                          (if (:const (meta v))\n                                            @v\n                                            (if (vars/isMacro v)\n                                              (throw (new #?(:clj IllegalStateException :cljs js/Error)\n                                                          (str \"Can't take value of a macro: \" v \"\")))\n                                              (types/->EvalVar v)))\n                                          :else (merge-meta v m)))\n                   ;; don't evaluate records, this check needs to go before map?\n                   ;; since a record is also a map\n                   (record? expr) expr\n                   (map? expr)\n                   (let [ks (keys expr)\n                         vs (vals expr)\n                         constant-map? (and constant-colls\n                                            (every? constant? ks)\n                                            (every? constant? vs))\n                         analyzed-map (if constant-map?\n                                        expr\n                                        ;; potential place for optimization\n                                        (zipmap (analyze-children ctx ks)\n                                                (analyze-children ctx vs)))\n                         analyzed-meta (when m (analyze ctx m))\n                         analyzed-meta (if (and constant-map?\n                                                ;; meta was also a constant-map\n                                                (identical? m analyzed-meta))\n                                         analyzed-meta\n                                         (assoc analyzed-meta :sci.impl/op :eval))]\n                     (if analyzed-meta\n                       (with-meta analyzed-map analyzed-meta)\n                       analyzed-map))\n                   (or (vector? expr) (set? expr))\n                   (let [constant-coll? (and constant-colls\n                                             (every? constant? expr))\n                         analyzed-coll (if constant-coll?\n                                         expr\n                                         (into (empty expr) (analyze-children ctx expr)))\n                         analyzed-meta (when m (analyze ctx m))\n                         analyzed-meta (if (and constant-coll?\n                                                (identical? m analyzed-meta))\n                                         analyzed-meta\n                                         (assoc analyzed-meta :sci.impl/op :eval))]\n                     (if analyzed-meta\n                       (with-meta analyzed-coll analyzed-meta)\n                       analyzed-coll))\n                   (seq? expr) (if (seq expr)\n                                 (merge-meta (analyze-call ctx expr top-level?) m)\n                                 ;; the empty list\n                                 expr)\n                   :else\n                   expr)]\n     ret)))\n\n;;;; Scratch\n\n(comment\n  )\n"]}