{"version":3,"sources":["rewrite_clj/zip/seqz.cljs"],"mappings":"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","names":["rewrite-clj.zip.seqz/seq?","zloc","cljs.core/contains?","rewrite-clj.zip.base/tag","rewrite-clj.zip.seqz/list?","cljs.core._EQ_","rewrite-clj.zip.seqz/vector?","rewrite-clj.zip.seqz/set?","rewrite-clj.zip.seqz/map?","js/Error","rewrite-clj.zip.seqz/map-seq","f","temp__5751__auto__","n0","rewrite-clj.zip.move/down","G__30016","cljs.core/iterate","loc","n","rewrite-clj.zip.move/right","cljs.core.take_while","cljs.core/identity","cljs.core/last","rewrite-clj.zip.move/up","rewrite-clj.zip.seqz/map-vals","parent","cljs.core/not","and__4210__auto__","clojure.zip/node","v0","v","rewrite-clj.zip.seqz/map-keys","rewrite-clj.zip.seqz/map","rewrite-clj.zip.seqz/get","k","cljs.core/integer?","G__30038","rewrite_clj.zip.findz.find_value","cljs.core.nth","G__30039","rewrite-clj.zip.seqz/assoc","vloc","rewrite-clj.zip.editz/replace","rewrite-clj.zip.insert/append-child"],"sourcesContent":["(ns rewrite-clj.zip.seqz\n  (:refer-clojure :exclude [map get assoc seq? vector? list? map? set?])\n  (:require [rewrite-clj.zip.base :as base]\n            [rewrite-clj.zip.editz :as e]\n            [rewrite-clj.zip.findz :as f]\n            [rewrite-clj.zip.insert :as i]\n            [rewrite-clj.zip.move :as m]\n            [clojure.zip :as z]))\n\n;; ## Predicates\n\n(defn seq?\n  [zloc]\n  (contains?\n    #{:forms :list :vector :set :map}\n    (base/tag zloc)))\n\n(defn list?\n  [zloc]\n  (= (base/tag zloc) :list))\n\n(defn vector?\n  [zloc]\n  (= (base/tag zloc) :vector))\n\n(defn set?\n  [zloc]\n  (= (base/tag zloc) :set))\n\n(defn map?\n  [zloc]\n  (= (base/tag zloc) :map))\n\n;; ## Map Operations\n\n(defn- map-seq\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if-let [n0 (m/down zloc)]\n    (some->> (f n0)\n             (iterate\n               (fn [loc]\n                 (if-let [n (m/right loc)]\n                   (f n))))\n             (take-while identity)\n             (last)\n             (m/up))\n    zloc))\n\n(defn map-vals\n  \"Apply function to all value nodes of the given map node.\"\n  [f zloc]\n  {:pre [(map? zloc)]}\n  (loop [loc (m/down zloc)\n         parent zloc]\n    (if-not (and loc (z/node loc))\n      parent\n      (if-let [v0 (m/right loc)]\n        (if-let [v (f v0)]\n          (recur (m/right v) (m/up v))\n          (recur (m/right v0) parent))\n        parent))))\n\n(defn map-keys\n  \"Apply function to all key nodes of the given map node.\"\n  [f zloc]\n  {:pre [(map? zloc)]}\n  (loop [loc (m/down zloc)\n         parent zloc]\n    (if-not (and loc (z/node loc))\n      parent\n      (if-let [v (f loc)]\n        (recur (m/right (m/right v)) (m/up v))\n        (recur (m/right (m/right loc)) parent)))))\n\n(defn map\n  \"Apply function to all value nodes in the given seq node. Iterates over\n   value nodes of maps but over each element of a seq.\"\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if (map? zloc)\n    (map-vals f zloc)\n    (map-seq f zloc)))\n\n;; ## Get/Assoc\n\n(defn get\n  \"If a map is given, get element with the given key; if a seq is given, get nth element.\"\n  [zloc k]\n  {:pre [(or (map? zloc) (and (seq? zloc) (integer? k)))]}\n  (if (map? zloc)\n    (some-> zloc m/down (f/find-value k) m/right)\n    (nth\n      (some->> (m/down zloc)\n               (iterate m/right)\n               (take-while identity))\n      k)))\n\n(defn assoc\n  \"Set map/seq element to the given value.\"\n  [zloc k v]\n  (if-let [vloc (get zloc k)]\n    (-> vloc (e/replace v) m/up)\n    (if (map? zloc)\n      (-> zloc\n          (i/append-child k)\n          (i/append-child v))\n      (throw\n        (js/Error.\n          (str \"index out of bounds: \" k))))))\n"]}